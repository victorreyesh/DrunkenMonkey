<?php
/**
 * @file
 * An API for a simple gradebook.
 */

/**
 * Implements hook_views_api().
 */
function gradebookapi_views_api() {
  return array('api' => 2.0);
}

/**
 * Implements hook_permission().
 */
function gradebookapi_permission() {
  return array(
    'admin gradebookapi' => array(
      'title' => t('Administer Gradebookapi'),
      'description' => t('Configure the Gradebook modules'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function gradebookapi_theme() {
  return array(
    'gradebookapi_assignment_notice' => array('variables' => array('node')),
  );
}

/**
 * Implements hook_menu().
 */
function gradebookapi_menu() {
  $items = array();
  $items['admin/structure/gradebook'] = array(
    'title'            => 'Gradebook',
    'description'      => 'Administer the suite of Gradebook modules.',
    'position'         => 'left',
    'weight'           => -5,
    'page callback'    => 'system_admin_menu_block_page',
    'access arguments' => array('access administration pages'),
    'file'             => 'system.admin.inc',
    'file path'        => drupal_get_path('module', 'system'),
  );

  $items['admin/structure/gradebook/gradebookapi'] = array(
    'title'            => 'Gradebook API',
    'description'      => 'Provides a gradebook API.',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('gradebookapi_admin_settings'),
    'access callback'  => 'user_access',
    'access arguments' => array('administer site configuration'),
    'file'             => 'gradebookapi.admin.inc',
    'type' => MENU_NORMAL_ITEM, // optional
  );

  return $items;
}

/**
 * Implements hook_help().
 */
function gradebookapi_help($path, $arg) {
  switch ($path) {
    case 'admin/help#gradebookapi':
      $output = '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The gradebook API provides a framework for developing gradebook user interfaces. Use the links below to configure the gradebook API.') . '</p>';
      return $output;
    case 'admin/structure/gradebook/gradebookapi':
      $output = '<strong>' . t('Indicate which of the following content types can be used as gradebook assignments. Their create content (add) forms will be given additional fields so the teacher can select the appropriate gradebook and to assign a possible number of points for the assignment.') . '</strong>';
      return $output;
  }
}

/**
 * Implements hook_user_view().
 *
 * @return NONE
 */

function gradebookapi_user_view($account, $view_mode, $langcode) {
  if (gradebookapi_is_student(NULL, $account)) {
    $account->content['gradebookapi'] = array(
      '#type' => 'fieldset',
      '#title' => t('Gradebook settings'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );

    $account->content['gradebookapi']['grade_update_email'] = array(
      '#title'          => t('Receive email notifications on grade update'),
      '#type'           => 'checkbox',
      '#default_value'  => isset($account->content['gradebookapi']['grade_update_email']) ? $account->content['gradebookapi']['grade_update_email'] : FALSE,
      '#description' => t('Check the box to receive emails notifying you when assignment grades are updated.'),
    );

    $account->content['gradebookapi']['assignment_update_email'] = array(
      '#title'          => t('Receive email notifications on assignment update'),
      '#type'           => 'checkbox',
      '#default_value'  => isset($account->content['gradebookapi']['assignment_update_email']) ? $account->content['gradebookapi']['assignment_update_email'] : FALSE,
      '#description' => t('Check the box to receive emails notifying you when assignments are posted or modified.'),
    );
  }
}

/**
 * Implements hook_user_delete().
 *
 * @return NONE
 */
function gradebookapi_user_delete($account) {
  drupal_set_message(t('Deleting gradebook grades for %name (uid %d) since account is being deleted',  array('%name' => $account->name, '%d' => $account->uid)));
  db_delete('gradebookapi_grade')->condition('uid', $account->uid)->execute();
  db_delete('gradebookapi_cache')->condition('uid', $account->uid)->execute();
  watchdog('gradebookapi', 'Deleted gradebook grades for %name (uid %d) upon deletion of account.', array('%name' => $account->name, '%d' => $account->uid), WATCHDOG_INFO);
}

/**
 * Retrieves the content types used for gradebook assignments.
 *
 * @return
 *   An array of content types that are used as gradebook assigments.
 */
function gradebookapi_get_assignment_types() {
  $field = field_info_field('gradebookapi_gradebook');
  $node_types = (empty($field['bundles']['node'])) ? array() : $field['bundles']['node'];
  return $node_types;
}

/**
 * Retrieves the gradebook taxonomy vocabulary id for gradebook terms (gradebooks and categories),
 * or creates one if it doesn't exist.
 *
 * @return
 *   The taxonomy vocabulary id for the gradebook.
 */
function gradebookapi_get_vid() {
  $vid = variable_get('gradebookapi_nav_vocabulary', '');
  if (empty($vid)) {
    // Check to see if a forum vocabulary exists
    $vid = db_query("SELECT vid FROM {taxonomy_vocabulary} WHERE module = :module", array(':module' => 'gradebookapi'))->fetchField();
    if (!$vid) {
      // The Gradebook vocabulary hasn't been created yet so we need to create it.
      $edit = array(
        'name' => 'Gradebook',
        'machine_name' => 'gradebook',
        'description' => '',
        'hierarchy' => 1,
        'module' => 'gradebookapi',
      );
      $vocabulary = (object)$edit;
      taxonomy_vocabulary_save($vocabulary);
      $vid = $vocabulary->vid;
      gradebookapi_create_field();
    }
    variable_set('gradebookapi_nav_vocabulary', $vid);
  }
  return $vid;
}

function gradebookapi_create_field() {
  // Check to see if our taxonomy field exists and create it if it does not.
  $fields = field_info_fields();
  if (!isset($fields['gradebookapi_gradebook'])) {
    $field = array(
      'translatable' => '1',
      'settings' => array(
        'allowed_values' => array(
          0 => array('vocabulary' => 'gradebook', 'parent' => '0'),
        ),
      ),
      'field_name' => 'gradebookapi_gradebook',
      'type' => 'taxonomy_term_reference',
      'module' => 'taxonomy',
    );
    field_create_field($field);
    drupal_set_message(t('Created new field gradebookapi_gradebook'));
  }
  else {
    drupal_set_message(t('Field gradebookapi_gradebook discovered.'));
  }
}

function gradebookapi_create_field_instance($node_types = array()) {

  // Create and remove gradebook field instances

  $current = gradebookapi_get_assignment_types();
  $removed = array_diff($current, $node_types);
  if (!empty($removed)) {
    foreach ($removed as $node_type) {
      $instance = field_info_instance('node', 'gradebookapi_gradebook', $node_type);
      field_delete_instance($instance);
      drupal_set_message(t('Marked gradebookapi_gradebook field attached to @type for deletion.', array('@type' => $node_type)));
    }
  }
  if (!empty($node_types)) {
    foreach ($node_types as $node_type) {
      $instance_data = field_info_instance('node', 'gradebookapi_gradebook', $node_type);
      if (!isset($instance_data) || !is_array($instance_data)) {
        $instance = array(
          'field_name' => 'gradebookapi_gradebook',
          'entity_type' => 'node',
          'bundle' => $node_type,
          'label' => t('Gradebook categories'),
          'description' => t('Select the gradebook category for this assignment'),
          'widget' => array('type' => 'options_select', 'module' => 'options'),
        );
        field_create_instance($instance);
        drupal_set_message(t('Attached gradebookapi_gradebook field to @type', array('@type' => $node_type)));
      }
      else {
        drupal_set_message(t('gradebookapi_gradebook field is attached to @type', array('@type' => $node_type)));
      }
    }
  }
}

/**
 * Retreives the gradebook taxonomy term from a term id.
 *
 * @param $tid
 *   The gradebook term id.
 * @return
 *   The taxonomy term for the requested gradebook, or FALSE if it doesn't exist.
 */
function gradebookapi_gradebook_load($tid) {
  if (_gradebookapi_is_root_term($tid)) {
    return taxonomy_term_load($tid);
  }
  else {
    return FALSE;
  }
}

/**
 * Helper function that determines if a term id is the root of the taxonomy tree.
 *
 * @param $tid
 *   The gradbook (or category) term id.
 * @return
 *   TRUE if $tid is the root, FALSE if it has parents
 */
function _gradebookapi_is_root_term($tid) {
  $parents = taxonomy_get_parents($tid);
  if (!empty($parents)) {
    return FALSE;
  }
  else {
    return TRUE;
  }
}

/**
 * Gets the parent term (gradebook) for a child tid (assignment category).
 * @param $tid
 *   The $tid for a gradebook category.
 * @return
 *   The parent gradebook (taxonomy term) for the category.
 */
function gradebookapi_get_tid_gradebook($tid) {
  $parents = taxonomy_get_parents_all($tid);
  return array_pop($parents);
}

function gradebookapi_gradebook_query() {
  $vid = gradebookapi_get_vid();
  $query = db_select('taxonomy_term_data', 't');
  $h_alias = $query->join('taxonomy_term_hierarchy', 'h', 't.tid = h.tid');
  $query->addField('t', 'tid');
  $query->distinct();
  $query->condition("{$h_alias}.parent", 0)->condition('t.vid', $vid);
  $result = $query->execute();
  return $result;
}

/**
 * Returns an array of all gradebooks.
 */
function gradebookapi_get_all_gradebooks() {
  $gradebooks = array();

  $result = gradebookapi_gradebook_query();

  foreach ($result as $record) {
    $gradebooks[] = gradebookapi_gradebook_load($record->tid);
  }
  return $gradebooks;
}

/**
 *  Retrieve an array of gradebook terms, table-sorted by header.
 *  Consider merging code with gradebookapi_get_all_gradebooks().
 */
function gradebookapi_gradebooks_table_query($header) {
  $vid = gradebookapi_get_vid();
  $query = db_select('taxonomy_term_data', 't')->extend('PagerDefault')->extend('TableSort');
  $h_alias = $query->join('taxonomy_term_hierarchy', 'h', 't.tid = h.tid');
  $query->fields('t', array('tid', 'name'))
    ->condition("{$h_alias}.parent", 0)->condition('t.vid', $vid)
    ->distinct();
  $result = $query
    ->orderByHeader($header)
    ->limit(variable_get('gradebook_gradebooks_per_page', 25))
    ->execute();

//  In D6 we had:
//  $sql  = 'SELECT DISTINCT t.tid, t.name FROM {term_data} t INNER JOIN {term_hierarchy} h ON t.tid = h.tid WHERE h.parent = 0 AND t.vid = '. $vid;
//  $sql .= tablesort_sql($header, 'weight, ');
//  $result = pager_query($sql, variable_get('gradebook_gradebooks_per_page', 25));

  return $result;
}

/**
 * Finds the gradebooks listing an assignment node.
 *
 * @param $node
 *   The assignment node.
 * @return
 *   An array of gradebook objects.
 */
function gradebookapi_assignment_get_gradebooks($node) {
  $gradebooks = array();
  $terms = gradebookapi_assignment_terms($node);
  foreach ($terms as $term) {
    if ($gradebook = gradebookapi_get_tid_gradebook($term->tid)) {
      $gradebooks[] = $gradebook;
    }
  }
  return $gradebooks;
}


/**
 *  Selects all the assignment nodes associated with a set of gradebook term ids.
 *  Particularly useful for a Gradebook page that lists all assignments in a gradebook and their grades.
 *
 *  @param $gradebook
 *    the gradebook object
 *  @param $tids
 *    an array of term ids (gradebook categories) to use in the search. If empty, use all gradebook categories
 *  @param $operator
 *    Optional: default is 'or' which ... otherwise ...
 *  @param $depth
 *    Optional: if set extend the taxonomy tree accordingly, otherwise include only root terms ?
 *  @param $pager
 *    Optional: Default is TRUE, perform a paged database query, set to FALSE to do a limited range query instead.
 *  @param $order
 *    Optional:  use this to modify the query sort order. The default it Sticky DESC, Created DESC.
 *  @return
 *    Database query result.
 */
function gradebookapi_select_nodes($gradebook, $tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order =  array('n.sticky' => 'DESC', 'n.created' => 'DESC')) {

  $vid = gradebookapi_get_vid();
  $tree = taxonomy_get_tree($vid, $gradebook->tid);
  $allowed_tids = array_map('_taxonomy_get_tid_from_term', $tree);
  $allowed_tids[] = $gradebook->tid;
  $use_tids = array();

  if (!count($tids)) {
    // use all tids in gradebook
    $use_tids = $allowed_tids;
  }
  else {
    // make sure tids are only in gradebook
    foreach ($tids as $tid) {
      if (in_array($tid, $allowed_tids)) {
        $use_tids[] = $tid;
      }
    }
  }
  return _gradebookapi_select_nodes($use_tids, $operator, $depth, $pager, $order);
}

/**
 * Helper function to select assignment nodes affiliated with a set of gradebook categories.
 * @see gradebookapi_select_nodes()
 */
function _gradebookapi_select_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = array('n.sticky' => 'DESC', 'n.created' => 'DESC')) {

  if (count($tids) > 0) {

    // For each term ID, generate an array of descendant term IDs to the right depth.
    $descendant_tids = array();
    if ($depth === 'all') {
      $depth = NULL;
    }
    foreach ($tids as $index => $tid) {
      if (is_numeric($tid)) {  // guard against null $tids...but what is the source of these?
        $term = taxonomy_term_load($tid);
        $tree = taxonomy_get_tree($term->vid, $tid, $depth);
        $descendant_tids[] = array_merge(array($tid), array_map('_taxonomy_get_tid_from_term', $tree));
      }
      else {
        unset($tids[$index]); // remove the offending $tid
      }
    }

    $dtids = call_user_func_array('array_merge', $descendant_tids);
    // Build the query object

    $query = db_select('node', 'n');

    if ($pager) {
      // Extend the query to get the PagerDefault object.
      $query = $query->extend('PagerDefault')->limit(variable_get('gradebook_grades_per_page', 10));
    }

    // Add a node_access tag (db_rewrite_sql replacement)
    $query->addTag('node_access')->fields('n', array('nid', 'sticky', 'title', 'created'));

    // Force filtering of duplicate records.
    $query->distinct();
    if ($operator == 'or') {
      // Add INNER JOINS
      $tn_alias = $query->join('taxonomy_index', 'tn', 'n.nid = tn.nid');
      $td_alias = $query->join('taxonomy_term_data', 'td', 'tn.tid = td.tid');
      $a_alias = $query->join('gradebookapi_assignment', 'a', 'n.nid = a.nid');

      // Add WHERE clause condition
      $query->condition("{$tn_alias}.tid", $dtids, 'IN');
    }
    else {
      $alias = $query->join('gradebookapi_assignment', 'a', 'n.nid = a.nid'); // possible to reorder this as above?
      foreach ($descendant_tids as $index => $tids) {
        $tn_alias = $query->join('taxonomy_index', 'tn', 'n.nid = tn' . $index . '.nid');  // use of $index here?
        $td_alias = $query->join('taxonomy_term_data', 'td', 'tn.tid = td' . $index . '.tid');  // use of $index here?
        $query->condition("{$tn_alias}.tid", $tids, 'IN');
      }
    }
    $query->condition('n.status', 1);

    // Add order - note change in the type of argument this requires.
    foreach ($order as $field => $direction) {
      $query->orderBy($field, $direction);
    }

    $result = $query->execute();

    return $result;
  }
}

/**
 * Retrieves the grade for the specified user and assignment.
 *
 * @param $uid
 *   The user id to use in the request.
 * @param $nid
 *   The assignment node id to use in the request.
 * @return $grade
 *   The grade object.
 *   If more than one grade exists only the last query is returned.
 *   If a grade has not been entered then a partial grade object with the possible value is returned.
 */
function gradebookapi_get_grade($uid, $nid) {
  $grades = gradebookapi_get_grades(array('uid' => $uid, 'nid' => $nid));
  if (count($grades)) {
    return array_pop($grades);
  }
  // if no grade exists, return grade with possible value
  else {
    $grade = db_query('SELECT * FROM {gradebookapi_assignment} a WHERE a.nid = :nid', array(':nid' => $nid))->fetchObject();
    $grade->uid = $uid;
    $grade->timestamp = 0; // use this to indicate that grade was not loaded from database
    return $grade;
  }
}

/**
 * Retrieves grade objects from the gradebookapi_grade and gradebookapi_assignment tables.
 *
 * @param $param
 *   an array of the form 'field' => $value to be used as the WHERE clause in an SQL query.
 *   Note: fields must be from gradebookapi_grade (uid, nid, earned, exempt, timestamp or note)
 * @return $grades
 *   an array of grade objects matching the constraint requested through $param.
 */
function gradebookapi_get_grades($param = array()) {
  $grades = array();

  $query = db_select('gradebookapi_grade', 'g');
  $alias = $query->join('gradebookapi_assignment', 'a', 'g.nid = a.nid');
  $query->fields('g', array('uid', 'nid', 'earned', 'exempt', 'timestamp', 'note'));
  $query->fields('a', array('possible', 'due_date', 'publish_date'));

  foreach ($param as $key => $value) {
    $query->condition('g.' . $key, $value);
  }
  $result = $query->execute();

  foreach ($result as $grade) {
    // can't use module_invoke here because it won't pass by reference..is there a better way to do this?
    $modules = module_implements('gradebookapi_grade');
    foreach ($modules as $module) {
      $func = $module . '_gradebookapi_grade';
      $func('get', $grade); //allows pass by reference!
    }
    $grades[] = $grade;
  }
  return $grades;
}

/**
 * Retrieves grade information by category and user from the gradebookapi_cache table.
 *
 * @param $uid
 *   The student user id
 * @param $tid
 *   The grade category term id
 * @return $grade
 *   A (partial) grade object
 */
function gradebookapi_get_term_grade($uid, $tid) {
  $grade = db_query("SELECT uid, tid, earned, possible FROM {gradebookapi_cache} WHERE tid = :tid AND uid = :uid", array(':tid' => $tid, ':uid' => $uid))->fetchObject();

  Return $grade;
}

/**
 * Updates or inserts the grade information into the gradebookapi_grade table.
 * The student's grades are then recalculated for each gradebook category.
 *
 * @param $grade
 *   The grade object.
 * @ return NONE
 */
function gradebookapi_set_grade($grade) {
  $old = gradebookapi_get_grade($grade->uid, $grade->nid);
  $grade->timestamp = REQUEST_TIME;
  if ($old->timestamp != 0) {
    db_update('gradebookapi_grade')
      ->fields(array('exempt' => $grade->exempt, 'timestamp' => $grade->timestamp, 'note' => $grade->note))
      ->condition('uid', $grade->uid)->condition('nid', $grade->nid)
      ->execute();
  }
  else {
    db_insert('gradebookapi_grade')
      ->fields(array(
        'uid' => $grade->uid,
        'nid' => $grade->nid ,
        'exempt' => $grade->exempt,
        'timestamp' => $grade->timestamp,
        'note' => $grade->note))
      ->execute();
  }

  db_update('gradebookapi_grade')
    ->fields(array('earned' => is_numeric($grade->earned) ? $grade->earned : NULL))
    ->condition('uid', $grade->uid)
    ->condition('nid', $grade->nid)
    ->execute();

  $node = node_load($grade->nid);
  $terms = _taxonomy_node_get_terms_by_vocabulary($node, gradebookapi_get_vid());
  foreach ($terms as $term) {
    gradebookapi_calc_grades($grade->uid, $term->tid);
  }
  $modules = module_implements('gradebookapi_grade');
  foreach ($modules as $module) {
    $func = $module . '_gradebookapi_grade';
    $func('set', $grade); //allows pass by reference!
  }

  gradebookapi_send_email('grade', array('assignment' => $node, 'grade' => $grade));

  // TODO: How does rules for D7 work? Check the next line.
  //  if (module_exists('rules')) {
  //    $account = user_load($grade->uid);
  //    rules_invoke_event('gradebookapi_set_grade', array('user' => $account, 'node' => &$node));
  // }
}

/**
 * Recursively re-calculates grades for each gradebook category and its children.
 *
 * @param $tid
 *   The gradebook category term id (parent or child).
 *
 * @return NONE
 */
function gradebookapi_rebuild_grades($tid) {
  $children = taxonomy_get_children($tid, gradebookapi_get_vid());
  if ($children) {
    foreach ($children as $child) {
      gradebookapi_rebuild_grades($child->tid);
    }
  }
  else {
    gradebookapi_calc_term_grades($tid);
  }
}

/**
 * Deletes term grades from the gradebookapi_cache table.
 *
 * @param $tid
 *   The gradebook category term id  (parent or child).
 * @param $recursive
 *   If TRUE, then all child term grades are also deleted.
 * @param $start
 *   If TRUE, then term grades will be recalculated.
 *
 * @return NONE
 */
function gradebookapi_clear_term_grades($tid, $recursive = TRUE, $start = TRUE) {
  db_delete('gradebookapi_cache')->condition('tid', $tid)->execute();
  // do a recursive delete?
  if ($recursive) {
    $children = taxonomy_get_children($tid, gradebookapi_get_vid());
    foreach ($children as $child) {
      gradebookapi_clear_term_grades($child->tid, $recursive, FALSE);
    }
  }
  // tell parents to recalc cache
  if ($start) {
    $parents = taxonomy_get_parents($tid);
    foreach ($parents as $parent) {
      gradebookapi_calc_term_grades($parent->tid);
    }
  }
}

/**
 * Calculates the student grade for a given gradebook category.
 *
 * @param $tid
 *   The gradebook category term id (parent or child).
 * @param $uid
 *   The student user id, if its < 1, then all grades are calculated.
 * @param $recursive
 *   If TRUE, then calc grades for all gradebook category child terms.
 *
 * @return NONE
 */
function gradebookapi_calc_grades($uid, $tid, $recursive=TRUE) {

  $gradebook = gradebookapi_get_tid_gradebook($tid);
  // if UID is < 1, calc grades for ALL users
  if ($uid <= 0) {
    return gradebookapi_calc_term_grades($tid);
  }
  else {
    // clear cache
    db_delete('gradebookapi_cache')->condition('tid', $tid)->condition('uid', $uid)->execute();

    // get grades from child terms
    $earned = 0;
    $possible = 0;
    $children = taxonomy_get_children($tid, gradebookapi_get_vid());
    foreach ($children as $child) {
      $grade = gradebookapi_get_term_grade($uid, $child->tid);

      if ($grade && !is_null($grade->earned)) {
        $earned += $grade->earned;
        $possible += $grade->possible;
      }
    }
    // get grades from nodes at this term
    $catearned = 0;   // earned grade at this term
    $catpossible = 0; // possible points at this term
    $result = gradebookapi_select_nodes($gradebook, array($tid), 'or', 0, FALSE);
    foreach ($result as $assignment) {
      $grade = gradebookapi_get_grade($uid, $assignment->nid);
      if ($grade && isset($grade->earned) && (!isset($grade->exempt) || (!$grade->exempt))) {
        $catearned += $grade->earned;
        $catpossible += $grade->possible;
      }
    }
    $weighted_grade = gradebookapi_weight_grade($gradebook->tid, $tid, $catpossible, $catearned);
    $earned += $weighted_grade['earned'];
    $possible += $weighted_grade['possible'];
    // cache grade
    db_insert('gradebookapi_cache')
      ->fields(array('uid' =>  $uid, 'tid' => $tid, 'earned' => $earned, 'possible' => $possible))
      ->execute();

    if ($recursive) {
      // recalc parents
      $parents = taxonomy_get_parents($tid);
      foreach ($parents as $parent) {
        gradebookapi_calc_grades($uid, $parent->tid, $recursive);
      }
    }
  }
}

/**
 * Provides a hook to weight the grade.
 *
 * If more than one module uses this hook, what to do with the several weights?
 * Avoid this by just popping one module name from the list of modules that implement.
 *
 * @param $gid
 *   The gradebook taxonomy (root) term id.
 * @param $tid
 *   The gradebook category.
 * @param $catpossible
 *   The possible points for the category.
 * @param $catearned
 *   The earned points for the category.
 *
 * @return
 *   Associative array with keys 'earned' and 'possible' for the weighted earned and possible grades.
 */
function gradebookapi_weight_grade($gid, $tid, $catpossible, $catearned) {
  $modules = module_implements('gradebookapi_weighted_grade');
  $module = array_pop($modules);
  return ($module) ?  module_invoke($module, 'gradebookapi_weighted_grade', $gid, $tid, $catpossible, $catearned) : array('earned' => $catearned, 'possible' => $catpossible);
}

/**
 * Provides a hook to let other modules specify the category weighting used by hook_gradebookapi_weighted_grade.
 *
 * @param $gid
 *   The gradebook taxonomy (root) term id.
 *
 * @return
 *
 */
function gradebookapi_get_weights($gid) {
  $modules = module_implements('gradebookapi_get_gradebook_weights');
  $module = array_pop($modules);
  return ($module) ?  module_invoke($module, 'gradebookapi_get_gradebook_weights', $gid) : array();
}

/**
 * Calculates all student grades for a gradebook or gradebook category.
 *
 * @param $tid
 *   The taxonomy term id to use to lookup grades on associated assignment nodes.
 * @param $recursive
 *   If TRUE (default), then all gradebook category child terms are also calculated.
 *
 * @return NONE
 */
function gradebookapi_calc_term_grades($tid, $recursive = TRUE) {
  $gradebook = gradebookapi_get_tid_gradebook($tid);
  $students = gradebookapi_get_students($gradebook);
  if (!empty($students['uid'])) {
    $query = db_select('users', 'u');
    $query->addField('u', 'uid');
    $query->condition('u.status', 0, '<>')->condition('u.uid', $students['uid'], 'IN');
    $query->orderBy('u.name', 'ASC');
    $result = $query->execute();
  }
  else {
    $result = FALSE;
  }
  if ($result) {
    foreach ($result as $account) {
      gradebookapi_calc_grades($account->uid, $tid, $recursive);
    }
  }
}

/**
 * Calculates the student grades for a given set of gradebook categories associated with an assignment.
 *
 * @param $node
 *   The assignment node.
 * @param $terms
 *   An array of gradebook category terms to calculate the grade for.
 *   If empty, then grades will be calculated for all categories.
 *
 * @return NONE
 */
function gradebookapi_calc_assignment_grades($node, $terms = array()) {

  if (empty($terms)) {
    $terms = gradebookapi_assignment_terms($node);
  }
  foreach ($terms as $term) {
    gradebookapi_calc_term_grades($term->tid);
  }
}

/**
 * Implements hook_taxonomy_vocabulary_delete().
 */
function gradebookapi_taxonomy_vocabulary_delete($vocabulary) {
  if ($vocabulary->vid == gradebookapi_get_vid()) {
    variable_del('gradebookapi_nav_vocabulary');
  }
}

/**
 * Implements hook_taxonomy_term_delete().
 */
function gradebookapi_taxonomy_term_delete($term) {
  if ($term->vid == gradebookapi_get_vid()) {

    // TODO: by the time we get here, the hierarchy has already been cleaned.
    //       how do we tell the parent to recalc?  Is this an issue anymore?
    // TODO: consider delete nodes associated with this term and it's children?

    gradebookapi_clear_term_grades($term->tid);
  }
}

/**
 * Retrieves all of the gradebook taxonomy terms associated with a node.
 *
 * @param $node
 *   The assignment node.
 *
 * @return
 *   An array of gradebook taxonomy terms.
 */
function gradebookapi_assignment_terms($node) {
  $terms = array();
  $vid = gradebookapi_get_vid();
  $terms = _taxonomy_node_get_terms_by_vocabulary($node, $vid);
  return $terms;
}

/**
 * Implements hook_node_load().
 * Retrieves the additional form fields from the gradebookapi_assignment database table.
 */
function gradebookapi_node_load($nodes, $types) {
  $result = db_query('SELECT * FROM {gradebookapi_assignment} g WHERE g.nid IN (:nids)', array(':nids' => array_keys($nodes)), array('fetch' => PDO::FETCH_ASSOC));
  foreach ($result as $record) {
    $nodes[$record['nid']]->gradebookapi = $record;
  }
}

/**
 * Implements hook_node_insert().
 */
function gradebookapi_node_insert($node) {
  // Inserts additional assignment fields into the gradebookapi_assignment database table.
  if (isset($node->gradebookapi)) {
    require_once('gradebook.datetime.inc');

    if (_gradebookapi_usedateapi()) {
      $node->gradebookapi['publish_date'] = _gradebookapi_datepopup2unixtime($node->gradebookapi['publish_date']);
      $node->gradebookapi['due_date'] = _gradebookapi_datepopup2unixtime($node->gradebookap['due_date']);
    }
    else {
      $node->gradebookapi['publish_date'] = _gradebookapi_drupaldate2unixtime($node->gradebookapi['publish_date']);
      $node->gradebookapi['due_date'] = _gradebookapi_drupaldate2unixtime($node->gradebookapi['due_date']);
    }
    $publish_date = $node->gradebookapi['publish_date'];
    $due_date = $node->gradebookapi['due_date'];
    $possible = $node->gradebookapi['possible'];

    $now = REQUEST_TIME;
    $node->status =  ($now > $publish_date) ? 1 : 0;

    // This assumes that gradebookapi has a lighter weight than any submodules so it is called first.
    db_insert('gradebookapi_assignment')
      ->fields(array('nid' => $node->nid, 'possible' => $possible, 'publish_date' => $publish_date, 'due_date' => $due_date))
      ->execute();

    // Note that taxonomy terms (fields) are automatically saved in D7 via the node_save API call.
    // by the time hook_node_insert() is called, the gradebook taxonomy terms have already been saved.

    // The grades are then recalculated since the possible value, etc. may have changed.
    gradebookapi_calc_assignment_grades($node);
  }
}

/**
 * Implements hook_node_update().
 * Updates additional assignment fields in the gradebookapi_assignment database table when the node is updated.
 *
 *  The grades are then recalculated since the possible value, etc. may have changed.
 *
 *  @param $node
 *    the assignment node.
 *
 *  @return NONE
 */
function gradebookapi_node_update($node) {
  if (isset($node->gradebookapi)) {
    require_once('gradebook.datetime.inc');

    if (_gradebookapi_usedateapi()) {
      $node->gradebookapi['publish_date'] = _gradebookapi_datepopup2unixtime($node->gradebookapi['publish_date']);
      $node->gradebookapi['due_date'] = _gradebookapi_datepopup2unixtime($node->gradebookap['due_date']);
    }
    else {
      $node->gradebookapi['publish_date'] = _gradebookapi_drupaldate2unixtime($node->gradebookapi['publish_date']);
      $node->gradebookapi['due_date'] = _gradebookapi_drupaldate2unixtime($node->gradebookapi['due_date']);
    }
    $publish_date = $node->gradebookapi['publish_date'];
    $due_date = $node->gradebookapi['due_date'];
    $possible = $node->gradebookapi['possible'];

    if (gradebookapi_is_assignment_node($node)) {  // this check is redundant, isn't it?
      db_update('gradebookapi_assignment')
        ->fields(array('possible' => $possible, 'publish_date' => $publish_date, 'due_date' => $due_date))
        ->condition('nid', $node->nid)
        ->execute();
    }
    else { // assignment doesn't exist in gradebookapi_assignment table, so insert it
      gradebookapi_node_insert($node);
    }

    // In D7, taxonomy terms (fields) are saved before hook_node_update is called,
    // so we can get the new gradebook terms from field_get_items using the current node.
    // This can be compared with the oldterms stored as part of the node object...

    $items = field_get_items('node', $node, 'gradebookapi_gradebook');
    $current = array();
    if (!empty($items)) {
      foreach ($items as $item) {
        $current[] = $item['tid'];
      }
    }
    $changed = array_diff($node->gradebookapi['oldterms'], $current);

    // If the term has changed, clear the term grade for the previous term.
    foreach ($changed as $tid) {
      // drupal_set_message("DEBUG - gradebookapi_node_update clearing term grades for changed term " . $tid);
      gradebookapi_calc_term_grades($tid);
    }

    // Finally, calculate the grade for this assignment;

    gradebookapi_calc_assignment_grades($node);

    gradebookapi_send_email('assignment', array('assignment' => $node));
  }
}

/**
 * Implements hook_node_delete().
 */
function gradebookapi_node_delete($node) {
  if (gradebookapi_is_assignment_node($node)) {
    // Deletes assignment field values from the gradebookapi_assignment database table when the node is deleted.

    // Delete records for all students for this assignment node.
    db_delete('gradebookapi_assignment')->condition('nid', $node->nid)->execute();
    // Delete grades for all users for this assignment node.
    db_delete('gradebookapi_grade')->condition('nid', $node->nid)->execute();

    // If taxonomy_node_delete has already been called, then we loose the info in
    // {taxonomy_index} needed to recalculate the grade instead, gather the gradebook api
    // terms associated with an assignment and send them into gradebookapi_calc_grades
    // to bypass the call to taxonomy_node_get_terms_by_vocabulary() (which will fail).

    //  The grades are then recalculated.
    $terms = gradebookapi_assignment_terms($node);
    gradebookapi_calc_assignment_grades($node, $terms);
  }
}

/**
 * Implements hook_node_view().
 */
function gradebookapi_node_view($node, $view_mode, $langcode) {
  if (gradebookapi_is_assignment_node($node)) {
    // Adds assignment field values to $node->content before rendering.
    $node->content['assignment_notice'] = array(
      '#markup' => theme('gradebookapi_assignment_notice', array('node' => $node)),
      '#weight' => -100,
    );
  }
}

/**
 * Determines if the node is an assignment node.
 *
 * @param $node
 *   The assignment node.
 *
 * @return
 *   TRUE if the node is an assignment node, FALSE otherwise.
 */
function gradebookapi_is_assignment_node($node) {
  $query = db_select('gradebookapi_assignment', 'g');
  $query->addField('g', 'nid');
  $query->condition('nid', $node->nid);
  $count = $query->countQuery()->execute()->fetchField();
  return ($count > 0);
}

/**
 * Provides a notice with assignment information on the assignment node.
 *
 * @param $node
 *   The assignment node.
 *
 * @return
 *   The HTML string ready to display.
 */
function theme_gradebookapi_assignment_notice($variables) {
  $node = $variables['node'];
  global $user;
  $account = user_load($user->uid);
  // Retrieve gradebook name and assignment category.
  $terms = gradebookapi_assignment_terms($node);
  // Collects gradebook name and category name for this assignment
  $gnames = array();
  $categories = array();
  foreach ($terms as $term) {
    // Retrieves the gradebook for this term and checks to see if the user in the gradebook.
    $gradebook = gradebookapi_get_tid_gradebook($term->tid);
    if (gradebookapi_is_student_or_teacher($gradebook, $account) && ($term->tid != $gradebook->tid)) {
      $gnames[$term->tid] = $gradebook->name;
      $categories[$term->tid] = $term->name;
    }
  }
  $output = '';
  if (!empty($gnames)) {
    $output = '<div class = "gradebook-assignment-notice">';
    $output .= '<ul class = "gradebook-assignment-category">';
    foreach ($categories as $tid => $category) {
      $output .= '<li>';
      $output .= t('@category Assignment for @course', array('@category' => $category, '@course' => $gnames[$tid]));
      $output .= '</li>';
    }
    $output .= '</ul>';

    if (isset($node->gradebookapi['possible'])) {
      $output .= '<p>';
      $output .= '<span class = "gradebook-assignment-possible">' . t('Assignment points possible') . ' : ' . '</span>';
      $output .= '<span class = "gradebook-assignment-possible-points">' . $node->gradebookapi['possible'] . '</span>';
      $output .= '</p>';
    }
    if (isset($node->gradebookapi['due_date'])) {
      $output .= '<p>';
      $output .= '<span class = "gradebook-assignment-due">' . t('This assignment is due on') . ' ' . '</span>';
      $output .= '<span class = "gradebook-assignment-due-date">' . format_date($node->gradebookapi['due_date'], 'custom', 'F j, Y');
      $output .= ' ' . t('at') . ' ' . format_date($node->gradebookapi['due_date'], 'custom', 'h:i a') . '</span>';
      $output .= '</p>';
    }
    $output .= '</div>';
  }
  return $output;
}

/**
 * Prepares extra assignment fields for the node create forms.
 *
 * @param $node
 *   The assignment node.
 *
 * @return $form
 *   Additional form array elements for the assignment create form.
 */
function gradebookapi_assignment_form_elements($node) {
  require_once('gradebook.datetime.inc');
  $form = array();

  $form['gradebookapi'] = array(
    '#type' => 'fieldset',
    '#title' => t('Assignment Settings'),
    '#tree' => TRUE,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#group' => 'additional_settings',
    '#weight' => -30,
    '#validate' => array('gradebookapi_assignment_validate' => array()),
  );
  $form['gradebookapi']['possible'] = array(
    '#type' => 'textfield',
    '#title' => t('Possible'),
    '#default_value' => (isset($node->gradebookapi['possible']) ? $node->gradebookapi['possible'] : '0'),
    '#size' => 10,
    '#maxlength' => 10,
    '#required' => TRUE,
  );
  if (!isset($node->gradebookapi['due_date'])) {
    $node->gradebookapi['due_date'] = strtotime(variable_get('gradebookapi_assignments_interval', '+1 month'));
  }

  if (!isset($node->gradebookapi['publish_date'])) {
    $node->gradebookapi['publish_date'] = REQUEST_TIME;
  }

  $datetype = _gradebookapi_usedateapi() ? 'date_popup': 'date';

  $default = is_numeric($node->gradebookapi['due_date']) ?  (
    ($datetype == 'date_popup') ?
      _gradebookapi_unixtime2datepopup( $node->gradebookapi['due_date']) : _gradebookapi_unixtime2drupaldate($node->gradebookapi['due_date']))    :  $node->gradebookapi['due_date'];

  $form['gradebookapi']['due_date'] = array(
    '#prefix' => '<div class="date_widget">',
    '#suffix' => '</div>',
    '#type' => $datetype,
    '#title' => t('Assignment due date'),
    '#default_value' => $default,
    '#date_label_position' => 'within',
    '#date_increment' => 15,
    '#date_year_range' => '-3:+3',
    '#date_format' => 'Y-m-d H:i',
  );

  $default = is_numeric($node->gradebookapi['publish_date']) ?  (
    ($datetype == 'date_popup') ?
    _gradebookapi_unixtime2datepopup($node->gradebookapi['publish_date']) : _gradebookapi_unixtime2drupaldate($node->gradebookapi['publish_date'])) :
    $node->gradebookapi['publish_date'];

  $form['gradebookapi']['publish_date'] = array(
    '#prefix' => '<div class="date_widget">',
    '#suffix' => '</div>',
    '#type' => $datetype,
    '#title' => t('Publish date'),
    '#default_value' => $default,
    '#date_label_position' => 'within',
    '#date_increment' => 15,
    '#date_year_range' => '-3:+3',
    '#date_format' => 'Y-m-d H:i',
  );

  // Store the old gradebook terms in case user changes categories.

  $items = field_get_items('node', $node, 'gradebookapi_gradebook');
  if (!empty($items)) {
    $form['gradebookapi']['oldterms'] = array();
    foreach ($items as $item) {
      $form['gradebookapi']['oldterms'][] = array('#type' => 'hidden', '#value' => $item['tid']);
    }
  }

  $form['#submit'][] = 'gradebookapi_assignment_submit';

  return $form;
}

/**
 * Implements hook_node_validate().
 *
 *  @param $node
 *    The assignment node.
 *  @param $form
 *    The $form parameter passed from node_validate.
 *
 *  @return NONE
 */
function gradebookapi_node_validate($node, $form, &$form_state) {
  if (gradebookapi_is_assignment_node($node)) {
    require_once('gradebook.datetime.inc');
    if (_gradebookapi_usedateapi()) {
      $due_date =  _gradebookapi_datepopup2unixtime($node->gradebookapi['due_date']);
      $publish_date = _gradebookapi_datepopup2unixtime($node->gradebookapi['publish_date']);
    }
    else {
      $due_date = _gradebookapi_drupaldate2unixtime($node->gradebookapi['due_date']);
      $publish_date = _gradebookapi_drupaldate2unixtime($node->gradebookapi['publish_date']);
    }
    if ($publish_date >= $due_date) {
      form_set_error('publish_date', t('The publish date of an assignment must be before its due date.'));
    }
  }
}

/**
 * Implements hook_node_submit().
 * This checks if the assignment should be marked as published.
 */
function gradebookapi_node_submit($node, $form, &$form_state) {
  if (isset($form_state['values']['gradebookapi'])) {
    $gradebookapi = $form_state['values']['gradebookapi'];
    require_once('gradebook.datetime.inc');
    if (_gradebookapi_usedateapi()) {
      $due_date = _gradebookapi_datepopup2unixtime($gradebookapi['due_date']);
      $publish_date = _gradebookapi_datepopup2unixtime($gradebookapi['publish_date']);
    }
    else {
      $due_date = _gradebookapi_drupaldate2unixtime($gradebookapi['due_date']);
      $publish_date = _gradebookapi_drupaldate2unixtime($gradebookapi['publish_date']);
    }

    $now = REQUEST_TIME;
    $form_state['values']['status'] = ($now >= $publish_date);
    if ($form_state['values']['status']) {
      drupal_set_message(t('The assignment is currently active.'));
    }
    else {
      drupal_set_message(t('The assignment will become active on !date.', array('!date' => format_date($publish_date, 'small'))));
    }
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function gradebookapi_form_node_form_alter(&$form, $form_state) {
  $node = $form['#node'];
  $types = gradebookapi_get_assignment_types();

  // Is this an assignment type?
  if (!empty($types)) {
    if (in_array($node->type, $types)) {
      $form += gradebookapi_assignment_form_elements($node);
    }
  }
}

/**
 * Determines whether a user is either a student or teacher for a given gradebook.
 * Used to control access to gradebook content.
 *
 * @param $gradebook
 *   The gradebook object.
 * @param $account
 *   The user object.
 *
 * @return
 *   TRUE if $account is a student, teacher or has uid=1, FALSE otherwise.
 */
function gradebookapi_is_student_or_teacher($gradebook = NULL, $account = NULL) {
  if (gradebookapi_is_student($gradebook, $account)) {
    return TRUE;
  }
  elseif (gradebookapi_is_teacher($gradebook, $account)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Determines whether a user is a student for a given gradebook.
 * Used to control access to gradebook content.
 *
 * @param $gradebook
 *   The gradebook object.
 * @param $account
 *   The user object.
 *
 * @return
 *   TRUE if $account is a student or has uid=1, FALSE otherwise.
 */
function gradebookapi_is_student($gradebook = NULL, $account = NULL) {
  global $user;

  if (is_null($account)) {
    $account = user_load($user->uid);
  }

  // User #1 has all privileges.
  if ($account->uid == 1) {
    return TRUE;
  }

  $students = gradebookapi_get_students($gradebook);
  if (in_array($account->uid, $students['uid'])) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Determines whether a user is a teacher for a given gradebook.
 * Used to control access to gradebook content.
 *
 * @param $gradebook
 *   The gradebook object.
 * @param $account
 *   The user object.
 *
 * @return
 *   TRUE if $account is a teacher or has uid=1, FALSE otherwise.
 */
function gradebookapi_is_teacher($gradebook = NULL, $account = NULL) {
  global $user;

  if (is_null($account)) {
    $account = user_load($user->uid);
  }

  // User #1 has all privileges.
  if ($account->uid == 1) {
    return TRUE;
  }

  $teachers = gradebookapi_get_teachers($gradebook);
  if (in_array($account->uid, $teachers['uid'])) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Gradebook UI modules determine which users are students and teachers.
 *
 * This is done by defining a function hook_gradebookapi_students that returns an array of user ids.
 * The api calls all of these hook functions and merges the results into one array.
 *
 * @param $gradebook
 *   The gradebook object. If NULL, then return teachers from all gradebooks.
 *
 * @return
 *   An array of student user ids.
 */
function gradebookapi_get_students($gradebook = NULL) {
  $students = array();
  $modules = module_implements('gradebookapi_students');
  $gradebooks = is_null($gradebook) ? gradebookapi_get_all_gradebooks() : array($gradebook);
  foreach ($gradebooks as $gradebook) {
    foreach ($modules as $module) {
      $function = $module . '_gradebookapi_students';
      $students = $function($gradebook, $students);
    }
  }
  return $students;
}

/**
 * Gradebook UI modules determine which users are teachers.
 *
 * This is done by defining a function hook_gradebookapi_teachers that returns an array of user ids.
 * The api calls all of these hook functions and merges the results into one array.
 *
 * @param $gradebook
 *   The gradebook object. If NULL, then return teachers from all gradebooks.
 *
 * @return
 *   An array of teacher user ids.
 */
function gradebookapi_get_teachers($gradebook = NULL) {
  $teachers = array();
  $modules = module_implements('gradebookapi_teachers');
  $gradebooks = is_null($gradebook) ? gradebookapi_get_all_gradebooks() : array($gradebook);
  foreach ($gradebooks as $gradebook) {
    foreach ($modules as $module) {
      $function = $module . '_gradebookapi_teachers';
      $teachers = $function($gradebook, $teachers);
    }
  }
  return $teachers;
}

/**
 * Implements hook_cron().
 *
 * This function allows gradebookapi to insert its own actions when
 * the cron.php script is run, usually by the system cron system. This is useful
 * when performing periodic asynchronous tasks like, as in this case, checking to
 * see if any assignments should be published.
 * * @return
 *   Nothing.
 *
 * More detail at @link http://api.drupal.org/api/HEAD/function/hook_cron API page @endlink .
 */

function gradebookapi_cron() {
  $types = (array)gradebookapi_get_assignment_types();
  $the_time = REQUEST_TIME;
  // Mark ready assignments as published.
  $nids = db_select('gradebookapi_assignment', 'n')->fields('n', array('nid'))->condition('publish_date', $the_time, '<=')->execute()->fetchAll();
  if (!empty($nids)) {
    db_update('node')->fields(array('status' => 1))->condition('type', $types, 'IN')->condition('status', 0)->condition('nid', $nids, 'IN')->execute();
  }
}

/**
 * Modifies date formats and publishes node if past the publish date.
 *
 * @param $node
 *   The assignment node object.
 */
function _gradebookapi_assignment_status(&$node) {
  require_once('gradebook.datetime.inc');
  if (_gradebookapi_usedateapi()) {
    $node->gradebookapi['publish_date'] = _gradebookapi_datepopup2unixtime($node->gradebookapi['publish_date']);
    $node->gradebookapi['due_date'] = _gradebookapi_datepopup2unixtime($node->gradebookapi['due_date']);
  }
  else {
    $node->gradebookapi['publish_date'] = _gradebookapi_drupaldate2unixtime($node->gradebookapi['publish_date']);
    $node->gradebookapi['due_date'] = _gradebookapi_drupaldate2unixtime($node->gradebookapi['due_date']);
  }
  $now = REQUEST_TIME;
  $node->status = ($now > $node->gradebookapi['publish_date']) ? 1 : 0;
}

/**
 * Determines whether the date popup should be used to select a date.
 *
 * @return
 *   TRUE if the date popup module exists and the use dateapi option is enabled.
 */
function _gradebookapi_usedateapi() {
  return (module_exists('date_popup') && variable_get('gradebookapi_use_dateapi', FALSE));
}

/**
 * Gradebook UI modules provide marks to replace numerical grades.
 *
 * This is done by defining a function hook_gradebookapi_marks that returns a string of not
 * more than five characters. It only makes sense to take one mark.
 *
 * @param $gid
 *   The gradebook term id.
 * @param $aid
 *   The assignment id.
 * @param $gradepoints.
 *   The earned points for the assignment.
 * @param $refresh
 *   A flag. When set to TRUE, reloads the mark lookup table.
 *
 * @return
 *   The mark corresponding to the grade.
 */
function gradebookapi_load_marks($gid, $aid = -1, $gradepoints, $refresh = FALSE) {
  $mark = module_invoke_all('gradebookapi_marks', $gid, $aid, $gradepoints, $refresh);
  return array_pop($mark);
}

/**
 * Send email to teachers when gradebook response has changed to completed.
 *
 * @param $type
 *   A string indicating the type of email notice to send (either 'grade' or 'assignment').
 * @param $objs
 *   An array of objects to use to construct the mail message.
 */
function gradebookapi_send_email($type, $objs) {
  // Obtain the gradebook(s) for the assignment.
  $gradebooks = array();
  $terms = gradebookapi_assignment_terms($objs['assignment']);
  foreach ($terms as $term) {
    // Retrieves the gradebook for this term and checks to see if the user in the gradebook.
    $gradebooks[] = gradebookapi_get_tid_gradebook($term->tid);
  }
  $params = array();
  // The sender of the email is the logged in user.
  global $user;
  $params['sender'] = user_load($user->uid);
  switch ($type) {
    case 'assignment':
      if (variable_get('gradebookapi_assignment_update_email_allowed', FALSE)) {
        $params['assignment'] = $objs['assignment'];
        // Notify all students in each gradebook for which this node is an assignment.
        foreach ($gradebooks as $gradebook) {
          $params['gradebook'] = $gradebook;
          $students = gradebookapi_get_students($gradebook);
          foreach ($students['uid'] as $uid) {
            $account = user_load($uid);
            if ($account->assignment_update_email) {
              $params['recipient'] = $account;
              drupal_mail('gradebookapi',
                          'gradebookapi_' . $type,
                          $params['recipient']->mail,
                          user_preferred_language($params['recipient']),
                          $params,
                          $params['sender']->mail);
            }
          }
        }
      }
      break;
    case 'grade':
      if (variable_get('gradebookapi_grade_update_email_allowed', FALSE)) {
        // Load the student user account.
        $grade = $objs['grade'];
        $account = user_load($grade->uid);
        if ($account->grade_update_email) {
          $params['recipient'] = $account;
          $params['gradebook'] = array_pop($gradebooks);
          $params['assignment'] = node_load($objs['grade']->nid);
          drupal_mail('gradebookapi',
                      'gradebookapi_' . $type,
                      $params['recipient']->mail,
                      user_preferred_language($params['recipient']),
                      $params,
                      $params['sender']->mail);
        }
      }
      break;
  }
}

/**
 * Implements hook_mail().
 */
function gradebookapi_mail($key, &$message, $params) {
  $sender = $params['sender'];
  $recipient = $params['recipient'];
  $assignment = $params['assignment'];
  $gradebook = $params['gradebook'];

  // Select the appropriate subject and body type based on the mail key.

  $subject = variable_get($key . '_update_email_subject', gradebookapi_email_format($key, 'subject'));
  $body = variable_get($key . '_update_email_body', gradebookapi_email_format($key, 'body'));

  $gradebookpath = 'gradebook/' . $gradebook->tid;
  $assignmentpath = 'node/' . $node->nid;

  $replace = array('%sender'       => $sender->name,
                   '%recipient'    => $recipient->name,
                   '%assignment'   => $assignment->title,
                   '%coursename'   => $gradebook->name,
                  '%assignmenturl' => url($assignmentpath, array('absolute' => TRUE)),
                   '%gradebookurl' => url($gradebookpath, array('absolute' => TRUE)),
                   '%sitename'     => variable_get('site_name', 'Drupal'),
                  );
  $message['subject']  = strtr($subject, $replace);
  $message['body'] = strtr($body, $replace);
}

/**
 * Returns the default email subject and body format for gradebookapi notifications.
 *
 * @param $type
 *   The type of email message to prepare, either 'assignment' or 'grade'.
 * @param $target
 *   The format string to return, either 'subject' or 'body'.
 *
 * @return
 *   A text string containing either the email subject or body format.
 */
function gradebookapi_email_format($type, $target) {
  $text = '';
  switch ($type) {
    case 'gradebookapi_grade':
      switch ($target) {
        case 'subject':
          $text = 'Your grade for %assignment has been assigned.';
          break;
        case 'body':
          $text = 'Dear %recipient, a grade has been assigned for the assignment %assignment on %sitename. You can view your grade by going to %gradebookurl.';
          break;
      }
      break;
    case 'gradebookapi_assignment':
      switch ($target) {
        case 'subject':
          $text = 'An assignment for %coursename has been published or updated.';
          break;
        case 'body':
          $text = 'Dear %recipient, an assignment named %assignment has been published on %sitename. You can view the assignment by going to %assignmenturl.';
          break;
      }
  }
  return $text;
}

/**
 * Finds all terms from a specific vocabulary that are attached to a specific node.
 *
 * @param $node
 *   The node you want to look up terms for.
 * @param $vid
 *   The taxonomy vocabulary you want to look up terms for.
 * @return
 *   An array of term objects.
 */
function _taxonomy_node_get_terms_by_vocabulary($node, $vid) {
  $result = db_query('SELECT t.tid, t.* FROM {taxonomy_term_data} t INNER JOIN {taxonomy_index} r ON r.tid = t.tid WHERE t.vid = :vid AND r.nid = :node_nid ORDER BY weight', array(':vid' => $vid, ':node_nid' => $node->nid));
  return $result->fetchAll();
}

/**
 * Finds all terms associated with a node.
 * Another D7 Replacement for Drupal 6 taxonomy_node_get_terms.
 */
function gradebookapi_taxonomy_node_get_terms($node, $key = 'tid') {
  static $terms;
  if (!isset($terms[$node->vid][$key])) {
    $query = db_select('taxonomy_index', 'r');
    $t_alias = $query->join('taxonomy_term_data', 't', 'r.tid = t.tid');
    $v_alias = $query->join('taxonomy_vocabulary', 'v', 't.vid = v.vid');
    $query->fields( $t_alias );
    $query->condition("r.nid", $node->nid);
    $result = $query->execute();
    $terms[$node->vid][$key] = array();
    foreach ($result as $term) {
      $terms[$node->vid][$key][$term->$key] = $term;
    }
  }
  return $terms[$node->vid][$key];
}